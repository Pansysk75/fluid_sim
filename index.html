<!DOCTYPE html>
<html>

<head>
    <title>Canvas Drawing</title>
</head>

<body>
    <canvas id="myCanvas" width="400" height="400"></canvas>

    <script>
        // Get the canvas element and its 2D context
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        class Fluid {
            constructor(size_x, size_y) {
                this.size_x = size_x
                this.size_y = size_y

                this.num_cells = this.size_x * this.size_y;

                this.u = Array(this.num_cells).fill(0) // Velocity in x direction
                this.v = Array(this.num_cells).fill(0) // Velocity in y direction

                this.s = Array(this.num_cells).fill(1.0) // "Fluidity" of cell

                for (var i = 0; i < this.size_x; i++) {
                    for (var j = 0; j < this.size_y; j++) {
                        if (i == 0 || j == 0 || i == this.size_x - 1) {
                            this.s[i * this.size_y + j] == 0.0;
                        }
                    }
                }

                this.p = Array(this.num_cells).fill(0) // Pressure

                this.new_u = Array(this.num_cells).fill(0)
                this.new_v = Array(this.num_cells).fill(0)

            }


            calc_gravity(dt) {
                // Add downward due to gravity
                const n = this.size_y;
                const gravity = 9.8 // m/s
                for (var i = 0; i < this.size_x; i++) {
                    for (var j = 0; j < this.size_y; j++) {
                        if (this.s[i * n + j] != 0.0 && this.s[i * n + j - 1] != 0.0) {
                            this.v[i * n + j] += gravity * dt;
                        }
                    }
                }
            }

            solve_incompressibility(dt, iterations) {
                // Since we assume an incompressible fluid, flow in must equal flow out for each cell
                const n = this.size_y;
                for (var iter = 0; iter < iterations; iter++) {
                    for (var i = 1; i < this.size_x - 1; i++) {
                        for (var j = 1; j < this.size_y - 1; j++) {

                            var d = - this.u[(i + 1) * n + j] + this.u[i * n + j] -
                                this.v[i * n + j + 1] + this.v[i * n + j]


                            var sx0 = this.s[(i - 1) * n + j];
                            var sx1 = this.s[(i + 1) * n + j];
                            var sy0 = this.s[i * n + j - 1];
                            var sy1 = this.s[i * n + j + 1];
                            var s = sx0 + sx1 + sy0 + sy1;

                            if (s == 0.0)
                                continue;

                            d = d / s
                            d = (1.8 * d)

                            this.p[i * n + j] += d // not accurate, but it's only used in visualization anyways

                            this.u[i * n + j] -= sx0 * d
                            this.v[i * n + j] -= sy0 * d
                            this.u[(i + 1) * n + j] += sx1 * d
                            this.v[(i * n + j + 1)] += sy1 * d
                        }
                    }
                }
            }


            get_u_at(x, y) {
                if (x > 0 && x < this.size_x &&
                    y > 0 && y < this.size_y) {
                    return this.u[x * this.size_y + y]
                } else {
                    return 0
                }
            }

            get_v_at(x, y) {
                if (x > 0 && x < this.size_x &&
                    y > 0 && y < this.size_y) {
                    return this.v[x * this.size_y + y]
                } else {
                    return 0
                }
            }
            interpolate_fluid(x, y) {
                // var v_avg = (this.get_v_at(x, y) + this.get_v_at(x + 1, y) + this.get_v_at(x - 1, y) + this.get_v_at(x, y + 1) + this.get_v_at(x, y - 1)) / 5
                // var u_avg = (this.get_u_at(x, y) + this.get_u_at(x + 1, y) + this.get_u_at(x - 1, y) + this.get_u_at(x, y + 1) + this.get_u_at(x, y - 1)) / 5

                var v_avg = (this.get_v_at(x, y) + this.get_v_at(x + 1, y)) / 2
                var u_avg = (this.get_u_at(x, y) + this.get_u_at(x + 1, y)) / 2

                return [u_avg, v_avg]
            }

            advect(dt) {
                // Since in reality a fluid is comprised of moving particles (and we only have a static grid),
                // we mimic the movement of particles by transferring velocities. Each cell inherits the velocity
                // of the cell where we estimate it would have "come from" (by subtracting u*dt from the current position).
                this.new_u = this.u.slice();
                this.new_v = this.v.slice();

                const n = this.size_y;

                for (var y = 0; y < this.size_y - 1; y++) {
                    for (var x = 0; x < this.size_x - 1; x++) {

                        var u_here = this.u[x * n + y]
                        var x_prev = Math.floor(x - u_here * dt)

                        var v_here = this.v[x * n + y]
                        var y_prev = Math.floor(y - v_here * dt)

                        var u_v_interp = this.interpolate_fluid(x_prev, y_prev)
                        this.new_u[x * n + y] = u_v_interp[0]
                        this.new_v[x * n + y] = u_v_interp[1]

                    }
                }

                this.u = this.new_u.slice();
                this.v = this.new_v.slice();

            }
        }

        var fluid = new Fluid(canvas.width, canvas.height)

        function draw() {

            id = ctx.getImageData(0, 0, canvas.width, canvas.height)

            var r = 0
            var g = 0
            var b = 0

            const n = fluid.size_y;

            var p = 0
            for (var i = 0; i < fluid.size_x; i++) {
                for (var j = 0; j < fluid.size_y; j++) {

                    r = fluid.p[j * n + i] * 255
                    g = fluid.u[j * n + i] * 255
                    b = fluid.v[j * n + i] * 255

                    // r = Math.max(fluid.v[j * n + i], 0)
                    // g = Math.max(fluid.u[j * n + i], 0)
                    // b = Math.max(-fluid.v[j * n + i], 0)

                    // r = r * 255 / 2
                    // g = g * 255 / 2
                    // b = b * 255 / 2

                    // r *= 0.01
                    // g *= 0.01
                    // b *= 0.01


                    id.data[p++] = r;
                    id.data[p++] = g;
                    id.data[p++] = b;
                    id.data[p++] = 255;
                }
            }

            ctx.putImageData(id, 0, 0);

        }

        var mouse_is_down = false
        var mouse_x = 0
        var mouse_y = 0
        
        function update() {
            fps = 60
            dt = (1 / (fps))

            fluid.calc_gravity(dt)
            fluid.p.fill(0.0);
            if (mouse_is_down) {
                fluid.u[(mouse_x - 1) * fluid.size_y + mouse_y] -= 1000
                fluid.u[(mouse_x + 2) * fluid.size_y + mouse_y] += 1000
                fluid.v[mouse_x * fluid.size_y + mouse_y - 1] -= 1000
                fluid.v[mouse_x * fluid.size_y + mouse_y + 2] += 1000
            }
            fluid.solve_incompressibility(dt, 1)

            fluid.advect(dt)
            draw()

            setTimeout(() => {
                requestAnimationFrame(update);
            }, 1000 / fps);
        }

        function getCursorPosition(canvas, event) {
            const rect = canvas.getBoundingClientRect()
            mouse_x = Math.floor(event.clientX - rect.left)
            mouse_y = Math.floor(event.clientY - rect.top)
            console.log("x: " + mouse_x + " y: " + mouse_y)
        }

        canvas.addEventListener('mousedown', function (e) {
            getCursorPosition(canvas, e)
            mouse_is_down = true
        })
        canvas.addEventListener('mousemove', event => {
            if (mouse_is_down) {
                const rect = canvas.getBoundingClientRect()
                mouse_x = Math.floor(event.clientX - rect.left)
                mouse_y = Math.floor(event.clientY - rect.top)
            }
        });
        canvas.addEventListener('mouseup', function (e) {
            mouse_is_down = false

        })


        update()

    </script>

</body>


</html>